/*
 * Area API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"database/sql"
	"flag"
	"fmt"
	mssql "github.com/denisenkom/go-mssqldb"
	"strconv"
	"time"
)

import _ "github.com/denisenkom/go-mssqldb"

// Parameters for connecting to DB // asa 15.12.2020
var (
	server   string
	database string
	user     string
	password string
	port     int
)

// Global variables 		// asa 15.12.2020
var DB *sql.DB = nil  // Connection pull to the DB
var flagFIRST int = 1 // flag , that this first entry in process of the webservice OR that DB reconnection needs
var rows *sql.Rows    // DB's ResultSet
var err error

//

// DefaultApiService is a service that implents the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API.
// Include any external packages or services that will be required by this service.
type DefaultApiService struct {
}

// NewDefaultApiService creates a default api service
func NewDefaultApiService() DefaultApiServicer {
	return &DefaultApiService{}
}

// FindPointIntersections - Метод возвращает зоны, которые пересекаются с точкой, координаты которой передаются в запросе.
func (s *DefaultApiService) FindPointIntersections(ctx context.Context, pointIntersectionRequest PointIntersectionRequest) (ImplResponse, error) {
	// TODO - update FindPointIntersections with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	var LevelsArray string
	var wdays string

	fmt.Println(pointIntersectionRequest.Levels)

	for p := 0; p <= len(pointIntersectionRequest.Levels)-1; p++ {
		LevelsArray += strconv.FormatInt(int64(pointIntersectionRequest.Levels[p]), 10) + ","
	}

	fmt.Println(LevelsArray)

	if flagFIRST == 1 { // if this is first invoke of this endpoint // asa 15.12.2020
		server1 := flag.String("server", "sqlsrv02.kupivip.local", "a string")
		database1 := flag.String("database", "GateStore", "a string")
		user1 := flag.String("user", "mo2", "a string")
		password1 := flag.String("password", "Ouy9gRplyFul0b9x", "a string")
		port1 := flag.Int("port", 1433, "an int")

		flag.Parse() //Parsing input args // asa 15.12.2020

		server = *server1
		database = *database1
		user = *user1
		password = *password1
		port = *port1

		flagFIRST = 0
	}

	resultSet := PointIntersectionResponse{}
	resultSet.Areas = make([]AreaIntersection, 0)

	//DB
	connString := fmt.Sprintf("server=%s;database=%s;user id=mo2;password=%s;port=%d", server, database, password, port)
	DB, err = sql.Open("mssql", connString) // Opening DB's connection pull
	if err != nil {
		fmt.Println("Error during connection with DB Server !!!")
		fmt.Println(err)

		if err == nil {
			fmt.Println("Connection with DB Server - OK !!!")
		}
	}

	rows, err = DB.Query("exec dbo.AreasThatContainThePoint '" + strconv.FormatFloat(pointIntersectionRequest.Latitude, 'f', 11, 64) + "','" + strconv.FormatFloat(pointIntersectionRequest.Longitude, 'f', 11, 64) + "','" + LevelsArray + "'")
	if err != nil {
		fmt.Println("Error during EXEC#1 !!!")
		fmt.Println(err)
	}

	var (
		Id1       int32
		Level1    int32
		Name1     string
		ParentId1 int32
		RouteId1  int64
	)

	var (
		from1 mssql.DateTime1
		to1   mssql.DateTime1
	)

	var wdays1 []WorkingDay
	var AreasStr string
	var AreaId int32
	var i int = 0

	for rows.Next() {
		err = rows.Scan(&Id1, &ParentId1, &Level1, &Name1, &RouteId1, &wdays)

		AreasStr += strconv.FormatInt(int64(Id1), 10) + ","

		wdays1 = make([]WorkingDay, 0)

		if wdays[0] == '1' {
			wdays1 = append(wdays1, "MONDAY")
		}

		if wdays[1] == '1' {
			wdays1 = append(wdays1, "TUESDAY")

		}
		if wdays[2] == '1' {
			wdays1 = append(wdays1, "WEDNESDAY")
		}

		if wdays[3] == '1' {
			wdays1 = append(wdays1, "THURSDAY")
		}

		if wdays[4] == '1' {
			wdays1 = append(wdays1, "FRIDAY")
		}

		if wdays[5] == '1' {
			wdays1 = append(wdays1, "SATURDAY")
		}

		if wdays[6] == '1' {
			wdays1 = append(wdays1, "SUNDAY")
		}

		resultSet.Areas = append(resultSet.Areas, AreaIntersection{Id1, ParentId1, Level1, Name1, RouteId1, wdays1, nil})
		fmt.Println(Name1)
		i++
	}
	err = rows.Err()

	defer rows.Close()

	fmt.Println(pointIntersectionRequest.Interval)

	if pointIntersectionRequest.Interval.From.Year() < 1900 {
		pointIntersectionRequest.Interval.From = pointIntersectionRequest.Interval.From.AddDate(1940, 1, 1)
	}

	if pointIntersectionRequest.Interval.To.Year() < 1900 {
		pointIntersectionRequest.Interval.To = pointIntersectionRequest.Interval.To.AddDate(1940, 1, 1)
	}

	fmt.Println(pointIntersectionRequest.Interval)

	rows, err := DB.QueryContext(ctx, `exec dbo.map_Select_AreaTime_Full_New_cache @AreasArray=?,@from=?,@to=?`,
		sql.Named("p1", AreasStr),
		sql.Named("p2", pointIntersectionRequest.Interval.From.Local()),
		sql.Named("p3", pointIntersectionRequest.Interval.To.Local()),
	)

	if err != nil {
		fmt.Println("Error during EXEC#2 !!!")
		fmt.Println(err)
	}

	var IntervalsArray []Interval
	var AreasArray []int32
	var IntervalsArray1 []Interval

	IntervalsArray = make([]Interval, 0)
	AreasArray = make([]int32, 0)

	for rows.Next() {
		err = rows.Scan(&AreaId, &from1, &to1)
		IntervalsArray = append(IntervalsArray, Interval{time.Time(from1), time.Time(to1)})
		AreasArray = append(AreasArray, AreaId)
	}

	for i := 0; i <= len(resultSet.Areas)-1; i++ {
		IntervalsArray1 = make([]Interval, 0)
		for j := 0; j <= len(AreasArray)-1; j++ {
			if resultSet.Areas[i].Id == AreasArray[j] {
				IntervalsArray1 = append(IntervalsArray1, IntervalsArray[j])
			}
		}
		resultSet.Areas[i].Intervals = IntervalsArray1
	}
	//TODO: Uncomment the next line to return response Response(200, PointIntersectionResponse{}) or use other options such as http.Ok ...
	//return Response(200, PointIntersectionResponse{}), nil
	return Response(200, resultSet), nil

}
